Para explicar el \ac{SW} que se ejecutará en \ac{S1} se va a hacer una división teórica entre el código que implementa la lógica de control y comunicaciones y el código que implementa la interfaz gráfica.

\subsection{Lógica}
Antes de proceder con la explicación del código conviene especificar ciertos aspectos destacados del \ac{SW}.

Al tener que comunicar \ac{S1} con \ac{S2}, es necesario que existan hilos de cómputo dedicados específicamente a las labores de lectura y escritura en la UART. Esto se debe a que no se debe ocupar el hilo principal de cómputo con labores de comunicación ya que esto supondría bloquear la interacción con la interfaz gráfica mientras duren las comunicaciones.
Por otro lado, es necesario un hilo especial para poder interactuar con uno de los elemento de la interfaz desde el hilo de comunicación.

Ante esta circunstancia se ha decidido que el \ac{SW} se ejecutará en hasta 4 hilos de cómputo distintos y concurrentes.

Dichos hilos son:

\begin{itemize}
    \item El hilo principal: en el se ejecuta la interfaz gráfica y la lógica de control siempre y cuando esta no suponga una comunicación con el \ac{S2}.
    \item Hilos dedicados a comunicación: estos hilos se crean bajo demanda al iniciarse una comunicación con \ac{S2} y se destruyen tras terminar su labor. Gracias a estos hilos, la interfaz gráfica puede seguir ejecutándose en el hilo principal.
    \item Hilo dedicado al demonio de pulsos: este hilo se crea tras realizarse la sincronización inicial. Su cometido es mandar mensajes periódicos a trasves de la UART para indicarle a \ac{S2} que \ac{S1} aún sigue conectado y que no se ha desconectado.
    \item Hilo dedicado a la actualización de la barra de progreso: este hilo se encarga de actualizar la barra de progreso que representa el porcentaje del movimiento que ya se ha realizado, creándose en el hilo de comunicación. El motivo por el cual es necesario actualizarlo desde un hilo distinto al principal es que solo \ac{S2} conoce cuánto tiempo tardará en realizarse el movimiento y, dado que el hilo principal no puede acceder a este dato hasta que el futuro acabe, es necesario que la interacción se haga desde un hilo que pueda acceder al dato de manera independiente e inmediata.
\end{itemize}

El modelo de comunicación asíncrona plantea ciertos problemas.

Uno de ellos es el acceso concurrente a recursos. Esto se puede observar en el acceso al canal de comunicaciones. El hilo demonio escribe de manera periódica en el canal de comunicación un mensaje, el cual sirve de pulso. Puede ocurrir que, de manera concurrente, sea necesario que un hilo de comunicación envíe una orden de movimiento a \ac{S2}.

Si el planificador de tareas del sistema operativo expulsa uno de los hilos en mitad de la comunicación y da paso al otro, los dos mensajes se mezclarían originando un fallo en la comunicación. 

Para evitar esta situación, el acceso a la UART es bloqueado siempre que un hilo accede a este recurso y no se desbloquea hasta que el hilo ha terminado la comunicación.

Otro problema es la comunicación de mensajes entre hilos y la sincronización de recepción y envió de estos. 

Este problema se origina ante la necesidad de que la interfaz gráfica se mantenga actualizada con los datos que se reciben en el hilo de comunicación. Para solucionarlo se han empleado futuros, los cuales pueden desencadenar la ejecución de una función en el hilo principal, cuando el futuro finaliza su ejecución.

Concretamente, el futuro que se ha implementado en \ac{S1} se encarga de ordenar el movimiento del brazo, monitorizarlo, recoger posibles errores, pedir las posiciones reales al acabar el movimiento y finalmente comunicarle dichas posiciones a la interfaz gráfica cuando esta las requiera.

%% INDICAR PREVIAMENTE QUE PUEDE DEVOLVER O BIEN EL ERROR QUE SE HAYA RECOGIDO
%% O BIEN LA INTERFAZ DE 'CONTROL' EN SÍ CON LAS POSICIONES ACTUALIZADAS
Además, el futuro puede contener los datos que la interfaz principal necesita y por tanto esta puede acceder a ellos.

%% UNIR CON LO DE ARRIBA PORQUE ES XD (SEGÚN MIHAI)

La lógica de control se ha dividido en varios paquetes para encapsular distintas funcionalidades del sistema por separado, estos paquetes son: ``\texttt{communications}'', ``\texttt{control}'', ``\texttt{gcode}'', ``\texttt{logger}'', ``\texttt{security}'' y ``\texttt{utils}''.

A continuación se procede a explicar la funcionalidad de cada uno de los paquetes a un nivel de abstracción alto, junto con una explicación más detallada de cada uno de los ficheros \texttt{.py}.

Además de las explicaciones dadas en esta sección, existen comentarios en el código que concretizan el funcionamiento de cada una de las funciones contenidas dentro de los distintos ficheros \texttt{.py}.

A continuación se procede a explicar cada uno de los paquetes.

\subsubsection{\texttt{communications}}
Este paquete gestiona las comunicaciones desde y hacia \ac{S1}. Su principal cometido es facilitar la operación y la lectura del búfer de recepción junto con la escritura por un puerto UART.

Contiene un único fichero, ``\texttt{connection.py}'' (anexo \ref{lst:connection_py}), en el cual están definidas todas las funciones relacionadas con la lectura y la escritura a través del puerto UART.

Es aquí donde, mediante el uso de cierres de exclusión mutua, se consigue que el acceso a la UART se haga de manera individual por parte de los procesos.

Cabe destacar que para poder utilizar este puerto para la comunicación se ha hecho uso de la librería ``\texttt{pyserial}''\footnote{\url{https://pypi.org/project/pyserial/}} de Python.

También se ha empleado la librería ``\texttt{threading}'' la cual de acceso a los cierres de exclusión mutua, llamados \textit{locks} en dicha librería.

\subsubsection{\texttt{control}}

Este paquete contiene la lógica de control propiamente dicha. Sirve para implementar los métodos principales de movimiento, de gestión de la comunicación, de creación del demonio de pulsos y de  sincronización inicial. Además, ofrece una interfaz lógica para que la interfaz de usuario pueda, a través de los botones que aparecen en pantalla, comunicarse con la lógica de control.

El paquete está conformado por 4 archivos:

\begin{itemize}
    \item \texttt{control.py}(anexo \ref{lst:control_py}): el cual implementa los métodos de movimiento y petición de posiciones además del método que desencadena el proceso de sincronización inicial. Es el archivo principal de control y sus funciones desencadenan llamadas a todos los demás paquetes para poder realizar funciones complejas.
    \item \texttt{control\_interface.py}(anexo \ref{lst:control_interface_py}): es una interfaz que implementa parte de los métodos de control.py. Este archivo es utilizado por la GUI para poder desencadenar acciones en \ac{S1} a partir de la interacción del operario con la interfaz gráfica.
    \item \texttt{control\_management.py}(anexo \ref{lst:control_management.py}): ofrece funciones auxiliares que permiten a control.py monitorizar que las órdenes enviadas a \ac{S2} son realizadas con éxito o, en caso contrario, controlar los errores que se pudieran producir.
    Además, aquí se encuentran las funciones que hacen peticiones a \ac{S2}.
    \item \texttt{\textit{heart\_beat}(anexo \ref{lst:heart_beat.py})}: ofrece funciones que permiten la instanciación de un objeto el cual envía un mensaje de manera periódica a través de la UART.
\end{itemize}

Cabe destacar que en este paquete se han utilizado librerías  que implementan el uso de futuros en Python con el objetivo de poder monitorizar el movimiento de \ac{S2} sin necesidad de bloquear la interfaz de usuario.

\subsubsection{\texttt{gcode}}

Aquí se encuentran la lógica de interpretación y generación de las tramas de GCODE que se transmiten entre \ac{S1} y \ac{S2}.

Contiene 2 ficheros:

\begin{itemize}
    \item \texttt{generator.py}(anexo \ref{lst:generator_py}): este archivo contiene las funciones que, a partir de los valores que reciben como parámetros, generan las tramas en el formato adecuado para ser enviadas.
    
    \item \texttt{interpreter.py}(anexo \ref{lst:interpreter_py}): analizador gramático de los \textit{bytes} que hay en el búfer de \ac{S1}.
    Para poder realizar esta labor, transforma los \textit{bytes} en cadena de caracteres y posteriormente analiza dichas cadenas y las interpreta.
\end{itemize}

Se ha usado la librería ''typing'' para simplificar el tratamiento de los datos y la interpretación de las tramas.

\subsubsection{\texttt{logger}}

Este paquete permite llevar un registro de los datos y las acciones importantes que ocurren en \ac{S1}. Genera un archivo en el que se guardan diferentes datos para poder hacer \textit{debugging} y revisar \textit{crashlogs}.

%% INSERTAR REFERENCIA AL FICHERO \ref{lst:---}
Contiene un único archivo, \texttt{logger.py}, el cual alberga las funciones necesarias para crear el archivo y operar con él, además de dar un formato estándar a las diferentes trazas.

En este paquete destaca el uso de la librería ``\texttt{logging}'' para poder generar registros de manera unificada y poder definir distintos niveles dentro de los registros, de manera que se pueden definir
niveles que serán ignorados.

\subsubsection{\texttt{security}}

A través de este paquete, \ac{S1} consigue autenticar al sistema \ac{S2} y viceversa.

%% INSERTAR REFERENCIA AL FICHERO \ref{lst:---}
Contiene un solo archivo, \texttt{rsa.py}, el cual alberga las funciones necesarias para que, a partir de los números procedentes de \ac{S2}, se pueda autenticar al emisor desde la trama recibida y poder reenviarla encriptada posteriormente.

%% typing ÚNICAMENTE SIRVE PARA AYUDAR AL PROGRAMADOR A DEFINIR QUÉ TIPOS DE DATOS
%% ACEPTA UNA FUNCIÓN, PERO NO 'PERMITE EL USO'.
% Se ha usado la librería typing para poder usar tipos de datos que simplificaran el proceso.

\subsubsection{\texttt{utils}}

En este paquete se encuentran todos los archivos auxiliares que no se puedan ubicar en ningún otro paquete.

%% INSERTAR REFERENCIA AL FICHERO \ref{lst:---}
Solo contiene un archivo, \texttt{error\_data.py}, el cual simplemente implementa un tipo de dato creado especialmente para poder contener de una manera más organizada los datos referentes a los errores provenientes de \ac{S2}.

Se emplea la librería \texttt{collections} para permitir el uso de tipos de datos auxiliares.

%% TO-DO - hablar de la librería atomics.py [J]

\subsubsection{\texttt{GUI}}
% TO-DO